# 연결 자료구조와 연결 리스트 1

### 순차 자료구조의 문제점

- 삽입 연산이나 삭제 연산 후에 연속적인 물리 주소를 유지하기 위해서 원소들을 이동시키는 추가 작업과 시간 소요
    - 원소들의 이동 작업으로 인한 오버헤드로 원소의 개수가 많고 삽입, 삭제 여산이 많이 발생하는 경우에 성능상의 문제 발생
- 순차 자료구조는 배열을 이용해 구현하기 때문에 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 가짐
- 순차 자료구조에서의 연산 시간에 대한 문제와 저장 공간에 대한 문제를 개선한 자료 표현 방법 필요

### 연결 자료구조

- 자료의 논리적인 순서와 물리적인 순서가 불일치
    - 각 원소에 저장되어 있는 다음 원소의 주소에 의해 순서가 연결되는 방식
        - 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않음
    - 여러 개의 작은 공간을 연결하여 하나의 전체 자료구조를 표현
        - 크기 변경이 우연하고 더 효율적으로 메모리를 사용
- 연결 리스트
    - 리스트의 연결 자료구조로 표현
    - 연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트
- 순차 자료구조
    - 한 덩어리로 된 소시지나 기차처럼 하나로 된 고정 크기 메모리 공간 사용
- 연결 자료구조
    - 줄줄이 소시지나 기차처럼 작은 공간을 여러 개 연결하여 전체를 표현

### 연결 리스트의 노드

- 연결 자료구조에서 하나의 원소를 표현하기 위한 단위 구조
- <원소, 주소>의 구조
  
  
    | data | link |
    | --- | --- |
- 데이터 필드 (data field)
    - 원소의 값을 저장
    - 저장할 원소의 형태에 따라서 하나 이상의 필드로 구성
- 링크 필드(link field)
    - 다음 노드의 주소를 저장
    - 포인터 변수를 사용하여 주소 값을 저장

### 연결 리스트의 이해

- 기차놀이 → 하나의 기차가 연결 리스트의 노드
- 기차가 가지고 있는 이름표 → 노드의 link필드

```c
<기차1, 기차2> <기차2, 기차3> <기차3, NULL>
```

- 선형 리스트 week의 연결 리스트 표현
  
    ```c
    <100번 메모리> <월, 160> <수, 130> <목, 200> <화, 120> <일, NULL> <금, 250> <토, 175>
    ```
    
- 선형 리스트와 연결 리스트의 비교
    - 리스트 이름(week) : 연결 리스트의 시작을 가리키는 포인터 변수
        - week는 연결 리스트의 첫 번째 노드를 가리킴과 동시에 연결된 리스트 전체 의미
    - 연결 리스트의 마지막 노드의 링크 필드 : 노드 끝을 표시하기 위해 NULL 저장
    - 공백 연결 리스트
        - 포인터 변수 week에 NULL 저장
    - 각 노드의 필드에 저장하는 겂은 점 연산자를 사용해 엑세스
        - week.data : 포인터 week가 가리키는 노드 데이터 필드 값 “월”
        - week.link : 포인터 week가 가리키는 노드 링크 필드에 저장된 주소값 “160”
    - 리스트 week의 노드에 대한 구조체 정의
      
        ```c
        typedef struct Node {
        	char data[4];
        	struct Node* link;
        };
        ```
        

### 단순 연결 리스트의 개념

- 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가짐
- 연결 리스트, 선형 연결 리스트, 단순 연결 선형 리스트
- 단순 연결 리스트에 노들를 삽입하는 방법
    1. 삽입할 노드를 준비한다.
    2. 새 노드의 데이터 피륻에 값을 저장한다.
    3. 새 노드의 링크값을 지정한다.
    4. 리스트의 앞 노드에 새 노드를 연결한다.
- 딘순 연결 리스트 week2=(월, 금, 일), “월”과”금” 사이에 “수” 삽입 과정
    - 초기 상태
      
        ```c
        <100> <월, 200> <금, 300> <일, NULL>
        ```
        
    1. 삽일할 노드 준비 : 공백 노드를 가져와 포인터 변수 new가 가리키게 함
    2. 새 노드의 데이터 필드값 저장 : new의 데이터 필드에 “수”를 저장
    3. 새 노드의 링크 필드값 지정 : new의 앞 노드, 즉 “월”노드의 링크 필드 값을 new의 링크 필드에 저장
    4. 리스트의 앞 노드에 새 노드 연결 : new의 값을 “월”노드의 링크 필드에 저장

### 단순 연결 리스트에서의 삭제 연산

1. 삭제할 노드의 앞 노드를 찾는다.
2. 앞 노드에 삭제할 노드의 링크 필드값을 저장한다.
3. 삭제한 노드의 앞 노드와 삭제한 노드의 다음 노드를 연결한다.
- 단순 연결 리스트 week2 = (월, 수, 금, 일) 에서 원소 “수” 삭제 과정
    - 초기 상태
      
        ```c
        <100> <월, 150> <수, 200> <금, 300> <일, NULL>
        ```
        
    1. 앞 노드를 찾음: 삭제할 원소의 앞 노드(선행자)를 찾음
    2. 앞 노드에 삭제할 노드의 링크 필드값 저장 : 삭제할 원소 “수”의 링크 필드값을 앞 노드의 링크 필드에 저장
    3. 삭제한 노드의 앞뒤 노드 연결 : 삭제한 노드의 앞 노드인 “월” 노드를 삭제한 노드의 다음 노드인 “금” 노드에 연결

### 단순 연결 리스트의 알고리즘

- 단순 연결 리스트의 첫 번째 노드로 삽입
  
    ```c
    insertFirstNode(L, x)
    1. new <- getNode()
    2. new.data <- x;
    3. new.link <- L;
    4. L <- new;
    end inertFirstNode()
    ```
    
    1. 새로운 node를 new가 가리킴
    2. new 데이터에 x를 삽입
    3. 삽입할 노드를 연결하기 위해서 리스트의 첫 번째 노드 주소(L)를 삽입할 새 노드 new의 링크 필드(new.link)에 저장하여, 새 노드 new가 리스트의 첫 번째 노드를 가리키게 한다.
    4. 리스트의 첫 번째 노드 주소를 저장하고 있는 포인터 L에 새 노드의 주소 new를 저장하여, 포인터 L이 새 노드를 첫 번째 노드로 가리키도록 지정

### 원형 연결 리스트의 개념

- 단순 열결 리스트에서 마지막 노드가 리스트의 첫 번재 노드를 가리키케 하여 리스트의 구조를 원형으로 만든 연결 리스트
    - 단순 연결 리스트의 마지막 노드의 링크 필드에 첫 번째 노드의 주소를 저장하여 구성
    - 링크를 다라 계속 순회하면 이전 노드에 접근 가능
    
    ```c
    <100> <월, 150> <수, 200> <금, 300> <일, 100>
    ```