# 자료구조 소개 3

### 알고리즘의 이해와 표현 방법, 알고리즘의 예와 성능 분석

### 알고리즘

- 문제해결 방법을 추상화하여 단계적 절차를 논리적으로 기술해 놓은 명세서

### 알고리즘의 조건

1. 입력(input)
    1. 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공될 수 있어야 함
2. 출력(output)
    1. 알고리즘 수행 후 하나 이상의 결과를 출력해야 함
3. 명확성
    1. 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게 명세되어야 함
4. 유한성
    1. 알고리즘은 수행 뒤에 반드시 종료되어야 함
5. 효과성
    1. 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 함

### 알고리즘의 표현 방법의 종류

1. 자연어를 이용한 서술적 표현 방법
2. 순서도를 이용한 도식화 표현 방법
3. 가상코드를 이용한 추상화 방법
4. 프로그래밍 언어를 이용한 구체화 방법

### 순서도를 이용한 도식화

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%89%E1%85%A9%E1%84%80%E1%85%A2%203%20ef8360ee6d0c495c946cf1fc6ec7dd55/Untitled.png)

### 가상코드를 이용한 추상화

- 카상코드, 즉 알고리즘 기술언어를 사용하여 프로그래밍 언어의 일반적인 형태와 유사하게 알고리즘을 표현
- 특정 프로그래밍 언어가 아니므로 직접 실행은 불가능
- 일반적인 프로그래밍 언어의 형태이므로 원하는 특정 프로그래밍 언어로의 변환 용이

### 가상코드의 형식

- 기본 요소
    - 기호
        - 변수, 자료형 이름, 프로그램 이름, 레코드 필드 명, 문장의 레이블 등을 나타냄
        - 문자나 숫자의 조합, 첫 문자는 반드시 영문자 사용
    - 자료형
        - 정수형과 실수형의 수치 자료형, 문자형, 논리형, 포인터, 문자열 등의 모든 자료형 사용
    - 연산자
        - 산술연산자, 관계연산자, 논리연산자
- 지정문 형식과 예
    - 변수 ← 값
        - a ← 5
        - a ← 3 + 2
        - a ← b;

### 조건문

- 조건에 따라 실행할 명령문이 결정되는 선택적 제어구조를 만듦
- if문의 형식
  
    ```bash
    if (조건식) then 명령문 1;
    else 명령문 2;
    ```
    
    ```bash
    if (조건식) then 명령문 1;
    ```
    
- 다단계 조건문
    - 중첩 if 문의 형식
      
        ```bash
        if (조건식 1) then 명령문 1;
        else if (조건식 2) then 명령문 2;
        else 명령문 3;
        ```
        
    - ex) 평균 점수에 따른 등급 계산하기
      
        ```bash
        if Average >= 90 then grade <- "A";
        else if Average >= 80 then grade <- "B";
        else if Average >= 70 then grade <- "C";
        else grade <= "F";
        ```
        
    - case문
        - 여러 조건식 중에서 해당 조건을 찾아서 그에 대한 명렁문을 수행
        - 중겁 if 문으로 표현 가능
        - 형식
          
            ```bash
            case {
            	조건식1 : 명령문1;
            	조건식2 : 명령문2;
            	...
            	조건식n : 명령문n;
            	else   : 명령문n+1;
            }    
            ```
            
        - ex ) 평균 점수에 따른 등급 계산하기
          
            ```bash
            case {
            	Average >= 90 : grade <- "A";
            	Average >= 80 : grade <- "B";
            	Average >= 70 : grade <- "C";
            	else          : grade <- "F"
            }
            ```
            

### 반복문

- 일정한 명령을 반복 수행하는 루프 형태의 제어구조
- for 문
    - 형식
    
    ```bash
     for (초기값; 조건식; 증감값) do 명령문;
    ```
    
    - 초기값 : 반복문을 시작하는 값
    - 조건식 : 반복 수행 여부를 검사하는 식
    - 증감값 : 반복 회수를 계산하기 위해서 반복문을 한 번 수행할 때마다 증가 또는 감소시키는
    
    값
    
- while - do 문
    - 조건식이 참인 동안 명령문을 반복 수행
    - 형식
      
        ```bash
        while (조건식) do 명령문;
        ```
    
- do - while 문
    - 일단 명령문을 한 반 실행한 수에 조건식을 검사하여 조선식이 참인 동안 명령문을 반복 수행
    - 형식
      
        ```bash
        do 명령문;
        while (조건식);
        ```
        

### 함수문

- 처리작업 별로 모듈화하여 만든 부프로그램
- 형식
  
    ```bash
    함수 이름(매개변수)
    	명령문;
    	...
    	return 결과값;
    end
    ```
    

### 알고리즘 성능 분석 기준

- 기준에는 정확성, 명확성, 수행량, 메모리 사용량, 최적성 등
    - 정확성 : 올바른 자료 입력 시 유한한 시간 내에 올바른 결과 출력 여부
    - 명확성 : 알고리즘이 얼마나 이해하기 쉽고 명확하게 작성되었는가?
        - 명확할수록 이해하거나 변경하기 쉬움
    - 수행량 : 일반적인 연산은 제외, 알고리즘의 특성을 나타내는 중요 연산을 모두 분석
    - 메모리 사용량 : 명렁어, 변수, 입출력 자료와 정보 저장
    - 최적성 : 시스템의 사용 환경과 요구 사항이 다르므로 조건에 맞는 최적의 알고리즘이 가장 중요
- 공간 복잡도
    - 알고리즘을 프로그램으로 실행하여 완료하기까지 필요한 총 저장 공간의 양
    - 공간 복잡도 = 고정 공간 + 가변 공간
- 시간 복잡도
    - 알고리즘을 프로그램으로 실행하여 완료하기까지의 총 소요시간
    - 시간 복잡도 = 컴파일 시간 + 실행 시간
        - 컴파일 시간 : 프로그램마다 거의 고정적인 시간 소요
        - 실행 시간 : 컴퓨터의 성능에 따라 달라질 수 있으므로 실제 실행히간 보다는 명령문의 실행 빈도수에 따라 계산
    - 실행 빈도수의 계산
        - 지정문, 조건문, 반복문 내의 제어문과 반환문은 실행시간 차이가 거의 없으므로 하나의 단위시간을 갖는 기본 명령문으로 취급
- 빅-오 표기법
    - O(f(n))과 같이 표기
    - Big Oh of f(n)으로 읽음
    - 함수의 상한을 나타내기 위한 표기법
        - 최악의 경우에도 g(n)의 수행 시간 안에는 알고리즘 수행 완료 보장
    - 먼저 실행 빈도수를 구하여 실행 시간 함수를 찾고, 이 함수값에 가장 큰 영향을 주는 n에 대한 항을 한 개 선택하여 계수는 생략하고 O의 오른쪽 괄호 안에 표시
    - 피보나치 수열의 실행 시간 함수가 `4n + 2` 이고, 가장 영향이 큰 항은 `4n`이라 여기서 계수 4를 생략하여 `O(n)` 으로 표기
    - f(n) = 3n + 2 = ?
        - 3n + 2 ≤ 4n for n ≥ 2
        - n = 2
        - c = 4
        - f(n) = O(n)
    - f(n) = 10n2(제곱) + 4n + 2 = ?
        - 10n2(제곱) + 4n + 2 ≤ 11n2(제곱) for n ≥ 5
        - n = 5
        - c = 11
        - f(n) = O(n2(제곱))
    - 최고차항이 빅-오의 표기법이 된다.
    - 상한이므로 가능한 작은 값으로 잡아야 유용
    - f(n) = O(n) and g(n) = O(n2) 이라면 f(n) + g(n) = O(n2)
        - 더 큰 값
    - f(n) = O(n log n) and g(n) = O(n2) 이라면 f(n) + g(n) = O(n2)
        - 더 큰 값
- 빅-오메가 표기법
    - Ω(f(n))
    - Big Omega of f(n)
    - 함수의 하한을 나타내기 위한 표기법
    - 어떤 알고리즘의 시간 복잡도가 Ω(g(n))으로 분석되었다면, 이 알고리즘 수행에는 적어도 g(n)의 수행 시간이 필요하다는 의미
- 빅-세타 표기법
    - θ(f(n))
    - Big Theta of f(n)
    - 상한과 하한이 같은 정확한 차수를 표현하기 위한 표기법
        - f(n) = θ(g(n)) 되려면 f(n) = O(g(n))이면서 f(n) = Ω(g(n)) 이어야 함
- 시간 복잡도를 정확히 계산할 수 있으면 빅-세타 표기법 사용
- 시간 복잡도를 정확히 계산할 수 없다면 빅-오 표기법 사용