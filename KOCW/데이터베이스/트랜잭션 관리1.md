# 트랜잭션 관리1

### 트랜잭션

- 데이터베이스의 일의 단위
    - 일이란 : 자료 만들고 생성하고 삭제하고
- 은행의 계좌 이체나 신용카드 처리 등
- 동시에 많은 사용자들이 접근하여 데이터베이스를 사용하게 됨
- 동시성 제어
    - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장해야 함
    - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
    - 여러 사용자나 여러 응용 프로그램들이 동시에 수행되어도 서로 간섭하지 못하도록 보장함
- 회복
    - 데이터베이스를 갱신하는 도중에 시스템이 고장 나도 데이터베이스의 일관성을 유지함
- 첫 번째 update문이 실행된 후 두 번째 update문이 수행하기 전에 시스템이 다운된 후 재가동되면 dbms는 어떻게 대응되어야 하나?
    - 2개가 모두 실행되거나 모두 안 되거나하도록 하나의 트랜잭션처럼 dbms가 보장해야 함

### 트랜잭션의 특성(ACID 특성)

- 원자성(Atomicity)
    - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음을 의미
    - dbms의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 드랜택션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
    - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재 수행함으로써 트랜잭션의 원자성을 보장함
- 일관성(Consistency)
    - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
- 고립성(Isolation)
    - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
    - 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
    - dbms의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
- 지속성(Durability)
    - 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
    - 완료된 트랜잭션의 효과는 시스템이 고장이 난 경우에도 데이터베이스에 반영됨
    - dbms의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함

### 트랜잭션의 완료(commit)

- 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨
- SQl 구문상으로 commit work

### 트랜잭션의 철회(rollback)

- 트랜잭션에서 변경하려는 내용이 데이터베이스에 일바문 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
- sql 구문상으로 rollback work

### 완료(commit) 이전의 데이터 상태

- 단지 메모리 버퍼에만 영향을 받았기 때문에 데이터의 변경 이전 상태로 복구가 가능
- 현재 사용자는 select 문장으로 변경된 결과를 확인 가능
- 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없음
- 변경된 행은 locking이 설정되어서 다른 사용자가 변경할 수 없음

### 완료(commit) 이후의 데이터 상태

- 데이터에 대한 변경 사항이 데이터베이스에 반영됨
- 이전 데이터는 영원히 잃어버리게 됨
- 모든 사용자는 결과를 볼 수 있음
- 관련된 행은 locking이 풀리고, 다른 사용자들이 행을 조작 가능

### 철회(rollback)이후의 데이터 상태

- 데이터에 대한 변경 사항이 취소됨
- 이전 데이터는 다시 재저장됨
- 관련된 행은 locking이 풀리고, 다른 사용자들이 행을 조작 가능

### 완료(commit)와 철회(rollback) 사용의 효과

- 데이터에 대한 무결성 보장
- 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
- 논리적으로 연관된 작업을 그룹핑하여 처리 가능

### 트랜잭션이 성공하지 못하는 원인

- 시스템 고장
- 트랜잭션 고장
- 매체 고장
- 통신고장
- 자연재해
- 부주의 또는 고의적인 고장

### 동시성 제어

- 대부분의 dbms들은 다수 사용자용
- 여러 사용자들이 동시에 동일한 테이블을 접근하기도 함
- dbms의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
- 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들간의 간섭이 생기지 않도록 함
- 직렬 스케줄
    - 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행
- 비직렬 스케줄
    - 여러 트랜잭션들을 동시에 수행
- 직렬 가능
    - 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등함
- 동시성 제어 하지 않으면 생길 수 있는 문제
    1. 갱신 손실
        1. 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효가 되는 것
    2. 오손 데이터 읽기
        1. 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
    3. 반복할 수 없는 읽기
        1. 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽음
    4. 모순성
        1. 같은 데이터 항목을 다른 트랜잭션이 동시에 접근할 때 잘못된 연산 결과가 발생함

### 타임 스탬프 순서

- 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표를 부여
- 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법으로 교착상태가 발생하지 않음

### 로킹

- 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법
- 로크는 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수
- 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 대마다 요청한 로크에 관한 정보는 로크 데이터 등에 유지
- 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 로크 해제
- 갱신, 읽은 에 따라 독점 로크, 공유 로크로 요청함

### 2단계 로킹 프로토콜

- 로크를 요청하는 것과 로크를 해제하는 것이 2단계로 이루어짐
- 로크 확장 단계가 지난 후에 로크 수축 단계에 들어감
- 일단 로크를 한 개라도 해제하면 로크 수축 단계에 들어감
- 로크 확장 단계(1단계)
- 로크 수축 단계(2단계)

### 데드록

- 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있음
- 데트록은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태
- 데드록을 해결하기 위해서는 데드록을 방지하는 기법이나, 데드록을 탐지하고 희생자를 선정하여 데드록을 푸는 기법 등을 사용함