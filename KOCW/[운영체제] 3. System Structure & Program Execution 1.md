# [운영체제] 3. System Structure & Program Execution 1

- 보통의 컴퓨터는 cpu, memory로 구성되어있음
- i/o device는 디스크, 모니터, 복합기, 마우스, 키보드 등

#### memory

- 메모리는 cpu의 작업공간

#### disk

- 아웃풋과 인풋의 역할을 수행

i/o 각 장치는 디바이스 컨트롤러가 있어서 이것이 작은 cpu역할을 함

cpu와 디스크의 성능차이는 많아 난다.

cpu는 메모리에서 읽었다 실행 읽었다 실행하는 역할

cpu에는 작은 메모리공간이 있는데 이것을 레지스터라고 부름

운영체제인지 사용자 프로그램인지 구분해주는게 메이드 빗

interrupt line이 존재

- 다음 실행을 메모리에서 작동하는데 i/o에서 요청한 걸 이 라인에서 실행해줌
- 메모리에서만 작업하는 것이 아니라 다른 장치와 소통해줌

cpu에서 필요한걸 디스크 컨트롤에 요청함

그동안 cpu는 메모리에 접근하여 인스트럭션을 실행

만약 키보드 입력이 오면 컨트롤러에게 키보드가 두드려지면 cpu에게 알려달라하고 메모리 일을 실행함

cpu는 계속 일함

#### 한 가지 문제점은?

- 무한루프 cpu를 사용하는 것이 cpu에 넘어가면 cpu를 계속 사용하게 된다.
- 다른 프로그램으로 넘어가지 못해 오류발생
- 그래서 timer하는 하드웨어가 존재
  - 특정 프로그램이 cpu를 사용하는 것을 방어
  - 사용자 프로그램을 cpu에 넘겨줄 때 timer에 특정 값을 주고 cpu에 넘겨줌
  - 세팅괸 시간이 되면은 timer가 cpu에 알려줌
    - 끝나면 interrupt line을 확인하고 없으면 다시 메모리 일을 함
  - 운영체제가 사용자 프로그램을 자유롭게 넘겨주지만 넘겨주고 나서는 뺏을 방법이 없음
    - 그래서 추가적인 timer을 주어준 것
    - 그래야 자유롭게 운영체제로 프로그램이 돌아옴
- i.o를 해야하면 프로그램이 자진해서 운영체제에게 cpu가 사용해야한다고 넘겨줌
- i/o컴트롤러가 요청한 작업이 끝나면 i/o 컨트롤러가 cpu 인터럽트를 걸고 운영체제는 인터럽트가 왜 걸렸는지 확인하고 전에 작업에 cpu를 넘겨줌
  - 할당된 시간이 끝나면 준비중인 프로그램에 주거나 할당된 시간이 남으면 작업중인 작업 계속 실행

#### Mode Bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요
- 두 가지 모드의 operation 지원
  - 1 사용자 모드
    - 사용자 프로그램 수행
    - cpu가 사용자 프로그램을 실행중일 때
    - 사용자 프로그램이 cpu를 가지고 있을 때 제한된 인스트럭션만 
    - 다른 프로그램에 접근하려면 막힘
  - 0 모니터 모드(커널 모드 시스템 모드)
    - OS 코드 수행
    - 운영체제가 cpu에서 수행중일 때
    - 무슨일이든 다 할 수 있도록 되어있음
  - 인터럽트나 Exception 발생 시 하드웨어가 모드빗을 0으로 바꿈
  - 사용자 프로그램에게 cpu를 넘기기 전에 모브 빗을 1로 셋팅

#### Timer

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
- 특정 프로그램이 cpu를 독점하는 것을 막기 위해서 사용자 프로그램을 넘길 때 시간을 설정해서 넘김
- 0이 되면 인터럽트 발생
- 그 프로그램부터 cpu를 뺐을 수 있게 구현

#### Decive Controller

- 제어 정보를 위한 컨트롤 레지스터, 상태 레지스터를 가짐
  - 지시를 위한 
  - 화면 출력은 제어 레지스터에서
- 로컬 버퍼도 있음
  - 데이터는 로컬 레지스터에 넣고
- 그러다보니 cpu가 인터럽트를 너무 많이 당함
  - 효율적이지 못함
  - 그래서 DMA 컨트롤러를 둠
    - 직접 메모리에 접근 할 수 있음
    - cpu도 접근하고 DMA도 접근
    - 메모리 컨트롤러는 cpu와 dma의 접근을 조정함
    - i/o 장치가 자주 인터럽트를 거니깐 cpu가 자주 방해를 받아서 cpu는 자기일을 계속하고 dma가 직접 메모리로 복사하고 cpu에는 한 번만 인터럽트 거는 것
    - cpu는 인터럽트 횟수 감소
- device driver(장치구동기)
  - os 코드 중 각 장치별 처리루틴 -> software
  - 디바이스에 인터페이스가 있는게 그거에 맞게 접근할 수 있도록
  - 본인이 일을 하기 위한 메뉴얼을 펌웨어
  - cpu가 실행하는 장치를 수행하기 위한 코드를 담고 있음
- device controller (장치제어기)
  - 각 장치를 통제하는 일종의 작은 CPU -> hardware

- cpu는 메뉴얼대로 일한다.
  - 메모리 몇 번지에 일을 해라
  - 그 다음 메뉴얼을 하고
  - 이 전체적인 통제를 운영체제가 함

#### 입출력의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 i/o를 하는가?
  - 시스템콜
    - 사용자 프로그램은 운영체제에게 i/o 요청
    - 사용자 프로그램이 커널 함수를 호출
  - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
  - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 i/o 요청인지 확인 후 i/o 수행
  - i/o 완료 시 제어권을 시스템콜 다음 명령으로 옮김

- i/o가 함수를 호출하는 것은 인터럽트를 거는 것 처럼 호출함
- 주소 점프를 하지 못함
  - 운영체제로 주소를 점프해야 함

#### 인터럽트

- 인터럽트
  - 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
  - 일반적인 인터럽트는 하드웨어의 인터럽트를 의미함
- interrupt(넓은 의미)
  - interrupt(하드웨어 인터럽트):하드웨어가 발생시킨 인터럽트
  - Trap(소프트웨어 인터럽트)
    - Exception
      - 프로그램이 오류를 범한 경우
    - System call
      - 프로그램이 커널 함수를 호출하는 경우
- 인터럽트 벡터
  - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
  - 각 인터럽트마다 어디있는 함수를 실행해야 하는지 정의해놓은 테이블 같은 것
- 인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)
  - 해당 인터럽트를 처리하는 커널 함수
- i/o가 끝났을 때 하드웨어 인터럽트가 걸린다.
- i/o를 하기 위해서 두가지 인터럽트 걸림
  - os가 시스템 콜을 함
  - 시킨일이 다 끝나면 i/o가 cpu에게 알려줌
  - 소프트웨어 콜 -> 하드웨어 콜
  - i/o 컨트롤러가 cpu에게 인터럽트를 걸음

#### 시스템 콜

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
- 사용자 프로그램이 운영체제를 직업 사용 못하니 cpu에 인터럽트를 걸고 cpu는 운영체제에게 시켜서 프로그램이 실행됨

