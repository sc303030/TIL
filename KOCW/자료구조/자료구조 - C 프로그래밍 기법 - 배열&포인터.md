# C 프로그래밍 기법: 배열&포인터

### 배열(array)

- 같은 자료형을 가진 자료들을 나열하여 메모리에 연속으로 저장하여 만든 자료들의 그룹
- 인덱스(index)
    - 배열의 요소를 간단히 구별하기 위해 사용하는 번호
    - C에서 인덱스는 항상 0부터 시작
- 모든 자료형에 대해서 배열로 구성 가능
- 구성 형태에 따라 1차원 배열, 2차원 배열, 3차원 배열 …

### 배열의 필요성

- 많은 변수를 선언해야 할 때 복잡하고 번거로움
- 배열의 선언
    - int floor[10]
        - 10개의 배열의 선언
        - 안에 요소가 10개 들어간다.
    - floor[0] → 첫 번째 요소

### 1차원 배열 선언 형식

- 자료형  배열이름  [배열요소의 개수];
- 자료형
    - 배열 요소는 모두 자료형이 같아야 하고, 배열 요소의 자료형이 배열의 자료형이 된다.
- 배열 이름
    - 변수 이름과 같은 규칙으로 정한다.
- 배열요소의 개수
    - 대괄호를 사용해 배열 요소의 개수를 표시하는데, 배열 소소 개수가 배열 크기
    - 배열을 선언하면 메모리에 배열에 대한 공간이 할당되고 그 크기는 자료형에 대한 `메모리 할당 크기 x 배열 소소의 개수`

### 1차원 배열의 초기화

- 1차원 배열의 초기화 형식
  
    ```bash
    자료형 배열이름[배열크기] = {초깃값 리스트};
    ```
    
- 예시
  
    ```c
    int A[5] = {1, 2, 3, 4, 5};
    ```
    
    - 또는
        - 배열의 모든 원소에 초깃값을 주면 배열 크기 생략 가능
    
    ```c
    int A[] = {1, 2, 3, 4, 5};
    ```
    
    - 초깃값 개수 < 배열 크기
        - 5를 선언하였기에 5 메모리를 차지함
        - 나머지는 0
    
    ```c
    int A[5] = {1, 2, 3};
    
    A[0] = 1;
    A[1] = 2;
    A[2] = 3;
    A[3] = 0;
    A[4] = 0;
    ```
    
    - 배열 크기 < 초깃값 개수
        - 공간은 3개로 할당되었음
        - 나머지 4, 5는 들어가지 못함
    
    ```c
    int A[3] = {1, 2, 3, 4, 5};
    
    A[0] = 1;
    A[1] = 2;
    A[2] = 3;
    A[3] = 4; -> 짤림
    A[4] = 5; -> 짤림
    ```
    

### 문자 배열

- 문자의 나열
- “와 “ 사이에 표시
- 문자열을 저장하기 위해서는 문자열을 구성하는 문자들을 연속적으로 저장해야 하기 때문에 char형 배열을 사용
- 배열의 자료형은 문자 자료형(char)
- 문지 베열의 초기화는 문자열 그대로 지정하거나 초기값 문자 리스트 사용
- 문자배열을 문자열 “String”으로 초기화 하는 예시
    - 6은 문자열이 끝났다는 뜻으로 null
    - 7 ~9는 공백
    
    ```c
    char s1[10] = "String";
    
    s1[0] = "S";
    s1[1] = "t";
    s1[2] = "r";
    s1[3] = "i";
    s1[4] = "n";
    s1[5] = "g";
    s1[6] = "\0";
    ```
    
- 초깂값 문자 리스트를 사용
    - string이 아니여서 null 값이 들어가지 않음
    
    ```c
    char s2[10] = {"S", "t", "r", "i", "n", "g"};
    
    s2[0] = "S";
    s2[1] = "t";
    s2[2] = "r";
    s2[3] = "i";
    s2[4] = "n";
    s2[5] = "g";
    ```
    
- s1을 초깃값 문자 리스트를 사용한 초기화
  
    ```c
    char s1[] = "String"; => char s1[] = {"S", "t", "r", "i", "n", "g", "\0"};
    ```
    

### 다차원 배열

- 2차원 이상의 배열

### 다차원 배열의 선언

- 배열의 차수 만큼 [배열크기] 항목을 추가
- 2차원 배열의 선언 형식
    - 행,열 순서
    
    ```c
    자료형  배열이름  [배열크기][배열크기]
                      행 개수   열 개수
                      행 번호   열 번호
    ```
    
- 2차원 배열 선언의 논리적 구조와 물리적 구조 예시
  
    ```c
    int i[2][3]
    ```
    
    - 논리적 구조
        - row major 형태
            - c언어에서는 행우선
            - 행에 있는 것부터 먼저
        
        | i[0][0] | i[0][1] | i[0][2] |
        | --- | --- | --- |
        | i[1][0] | i[1][1] | i[1][2] |
    - 물리적 구조
      
      
        | i[0][0] |
        | --- |
        | i[0][1] |
        | i[0][2] |
        | i[1][0] |
        | i[1][1] |
        | i[1][2] |
- 3차원 배열의 선언 형식
  
    ```c
    자료형 배열이름 [배열크기][배열크기][배열크기]
                    면 개수   행 개수   열 개수
    ```
    
    - 3차원 배열 선언 예시
      
        ```c
        int i[2][2][3]
        ```
        
    - 논리적 구조
        - 면0
          
          
            | i[0][0] | i[0][1] | i[0][2] |
            | --- | --- | --- |
            | i[1][0] | i[1][1] | i[1][2] |
        - 면1
          
          
            | i[0][0] | i[0][1] | i[0][2] |
            | --- | --- | --- |
            | i[1][0] | i[1][1] | i[1][2] |
    - 물리적 구조
      
      
        | i[0][0][0] |
        | --- |
        | i[0][0][1] |
        | i[0][0][2] |
        | i[1][1][0] |
        | i[1][1][1] |
        | i[1][1][2] |

### 다차원 배열의 초기화

- 초기값의 지정형태는 다차원 배열이 배열의 배열이라는 것을 생각하여 초기값을 구분하여 지정하거나, 1차원 배열처럼 초기값 리스트를 지정하여 순서대로 배열요소의 초기값으로 설정
- 2차원 배열의 초가화와 논리적 구조
  
    ```c
    int i[2][3] = {{1, 2, 3}, {4, 5, 6}} or int i[2][3] = {1, 2, 3, 4, 5, 6}
    ```
    
    | 1 | 2 | 3 |
    | --- | --- | --- |
    | 4 | 5 | 6 |
    - 행 크기를 생략란 2차원 배열의 초기화
    
    ```c
    int i[][3] = {{1, 2, 3}, {4, 5, 6}} or int i[][3] = {1, 2, 3, 4, 5, 6}
    ```
    
- 3차원 배열의 초기화와 논리적 구조;
  
    ```c
    int i[2][2][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
    ```
    
    - 면0
      
      
        | 1 | 2 | 3 |
        | --- | --- | --- |
        | 4 | 5 | 6 |
    - 면1
      
      
        | 7 | 8 | 9 |
        | --- | --- | --- |
        | 10 | 11 | 12 |

### 문자 다차원 배열

- 2차원 문자 배열의 선언
  
    ```c
    char c[3][20];
    ```
    
- 2차원 문자 배열의 문자열 저장과 논리적 구조
    - 행은 3개, 열은 20개
    - 안에 들어가는 요소가 숫자인지 문자인지 차이
    
    ```c
    char c[3][6] = ( "One",
    									"Two",
    									"Three");
    ```
    
    | O | n | e | \0 |  |  |
    | --- | --- | --- | --- | --- | --- |
    | T | w | o | \0 |  |  |
    | T | h | r | e | e | \0 |

### 포인터 개념

- 변수의 메모리 주소값
    - 값을 가지고 있는 번지
- 포인터변수
    - 주소값을 저장하는 특별한 변수
    - 포인터 변수가 어떤 변수의 주소를 저장하고 있다는 것은 포인터 변수가 그 변수를 가리키고 있다는 의미
    - 포인터 변수를 이용하여, 연결된 주소의 변수 영역을 엑섹스함
    - 포인터 변수를 간단히 포인터라고 함
- 포인터 사용 예
    - 포인터 앞에 *
    - &가 주소
    - i에는 값이 들어있음
    - 그 값을 가지고 있는 메모리 상의 번지가 있음
    - ptr변수에는 메모리 상의 번지가 들어감
    - *까지 사용하면 그 메모리 번지의 값을 말함
    
    ```c
    int i;
    int *ptr = &i;
    ```
    

### 포인터 선언

- 포인터 선언 형식
    - 자료형 : 포인터 자체의 자료형이 아니라 포인터에 저장할 주소에 있는 일반 변수의 자료형이다.
    - 포인터 이름 : 일반 변수 이름과 구별되도록 앞에 *를 붙여 포인터임을 나타낸다.
    
    ```c
    자료형 *포인터이름;
    ```
    
- 포인터를 다양한 자료형으로 선언한 예
    1. 1바이트의 char형 변수의 주소를 저장할 포인터를 선언한 예
        1. ptr에 저장된 메모리 주소로부터 1바이트의 char 데이터를 엑세스
        
        ```c
        char *ptr;
        ```
        
    2. 2바이트의 short형 변수의 주소를 저장할 포인터를 선언한 예
        1. ptr에 저장된 메모리 주소로부터 2바이트의 short 데이터를 엑세스
        
        ```c
        short *ptr;
        ```
        
    3. 4바이트의 int형 변수의 주소를 저장할 포인터를 선언한 예
        1. ptr에 저장된 메모리 주소로부터 4바이트의 int 데이터를 엑세스
        
        ```c
        int *ptr;
        ```
        

### 포인터 연산자

- 주소 연산자 : &
    - 변수의 주소를 얻기 위해 사용
    - 형식
      
        ```c
        포인터 = &변수;
        ```
    
- 예시
    - 150번지에 10이 들어있음
        - 150 ~ 153번지 까지 2진수로 채워져있음
        - ptr에는 150번지가 들어있음
    
    ```c
    int i = 10;
    int * ptr;
    ```
    
    ```c
    ptr = &i;
    ```
    
- 참조 연산자 : *
    - 저장된 주소에 있는 값(변수에 저장된 값)을 엑세스하는 연산자
    - 형식
      
        ```c
        *포인터 = 값;
        변수 = *포인터;
        ```
        
    - 예시
        - i = 20번지
        - j = 21번지
        
        ```c
        int i, j;
        int *ptr;
        ptr = &i; ...(1)
        *ptr = 10; ...(2)
        j = *ptr; ...(3)
        
        ```
        
        1. 주소 연산자를 사용하여 변수 i의 주소를 포인터 ptr에 할당한다. 포인터 ptr은 변수 i를 가리킨다.
        2. 참조 연산자를 사용하여 포인터 prt이 가리키는 영역에 값 10을 지정한다. 따라서 변수 i에는 10이 저장된다.
        3. 다시 참조 연산자를 사용하여 ptr이 가리키는 영역의 값을 변수 j에 지정한다. 따라서 ptr이 가리키는 변수 i의 값인 10을 변수 j에 저장한다.

### 포인터의 초기화

- 일반 변수를 초기화하는 방법과 같음
    - 포인터에 주소 지정 방법
        1. 주소 연산자를 사용하여 변수 주소를 지정
           
            ```c
            int i;
            int *ptr = &i;
            ```
            
        2. 동적 메모리를 할당하여  그 시작 주소를 포인터 값으로 지정
           
            ```c
            char *ptr = (char *)malloc(100);
            ```
            
        3. 문자형 포인터에 문자열의 시작 주소를 지정
            1. k의 시작 주소를 가리킴
            
            ```c
            char *ptr = "korea";
            ```
            
        4. 배열 이름을 이용하여 배열 시작 주소를 지정
            1. A[0]의 주소를 가리킴
            
            ```c
            char A[100];
            char *ptr = A;
            ```
            
        5. 배열의 첫 번째 요소의 주소를 이용하여 배열 시작 주소를 지정
           
            ```c
            char A[100];
            char *ptr = &A[0];
            ```
            

### 포인터 배열

- 포인터 자료형을 배열로 구성
    - 여러 개의 포인터를 하나의 배열로 구성한 배열의 특징과 포인터의 특징을 모두 활용할 수 있다.
- 포인터 배열의 선언형식
  
    ```c
    자료형 *포인터배열이름 [배열크기];
    ```
    
    - 포인터 배열에서 각 배열요소는 포인터
    - 2차원 문자배열을 1차원 포인터 배열로 표현
        - 2차원 배열의 행의 개수 : 포인터 배열의 크기
        - 포인터 배열의 각 배열요소 : 각 문자열에 대한 시작주소를 가진 포인터
- 2차원 배열과 1차원 포인터 배열의 비교
  
    ```c
    char string[3][10] = {"One", "two", "Three"};
    ```
    
    | O | n | e | \0 |  |  |
    | --- | --- | --- | --- | --- | --- |
    | T | w | o | \0 |  |  |
    | T | h | r | e | e | \0 |
    
    ```c
    char *ptr[3] = {{"One"), {"Two"), ("Three"));
    ```
    
    - ptr[0]→
      
      
        | O | n | e | \0 |
        | --- | --- | --- | --- |
    - ptr[1] →
      
      
        | T | w | o | \0 |
        | --- | --- | --- | --- |
    - ptr[2] →
      
      
        | T | h | r | e | e | \0 |
        | --- | --- | --- | --- | --- | --- |
- 2개의 차이점은 열이 고정인지 아닌지
    - 1번은 빈공간 존재 → 비효율
- 2차원 배열
    - 배열이 선언될 때 지정한 크기의 배열 공간이 메모리에 할당됨
    - 한 번 할당된 배열의 크기를 줄이거나 늘리기 어려움
    - 처음 선언한 배열의 크기보다 실제 사용 공간이 작으면 메모리가 낭비됨
    - 실제 필요한 공간이 할당 크기보다 크면 배열을 새로 만들어야 함
    - 위의 1번 처럼
- 1차원 포인터 배열
    - 저장하는 문자열의 길이에 따라 메모리가 할당됨
    - 저장할 문자열의 길이를 정확히 에측할 수 없거나 문자열의 길이가 자주 변하는 경우에 메모리를 좀 더 효율적으로 사용할 수 있음
    - 위의 2번 처럼

### 포인터의 포인터

- 포인터를 가리키고 있는 포인터, 이중 포인터
- 포인터의 주소를 가지고 있는 포인터
- 포인터의 포인터 선언 형식과 예
  
    ```c
    자료형 **포인터이름;
    ```
    
    ```c
    	char **ptr;
    ```
    
    - ptr → *ptr → char변수