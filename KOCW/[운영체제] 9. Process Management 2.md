# [KOCW] [운영체제] 9. Process Management 2

출처 : http://www.kocw.net/home/cview.do?lid=3a5437eaa6c9e5b0

### 프로세스 생성

- cpu의 인스트럭션을 어디까지 사용했는지 등도 복제
- 리눅스 등은 자식이 부모의 주소를 공유함
  - 결국은 각자의 길을 가게 됨
  - 그때야 부모의 일부를 자식이 복사함(copy-on-write (cow))
    - 내용이 같으면 공유해도 되지만 다르면 일부만 복제

- 일단 복제생성하고 필요하면 덮어씌움

### fork() 시스템 콜

- A porcess is created by the fork() system call
  - creates a new address space that is duplicate of the caller

```c++
int main()
{
	int pid;
	pid = fork();
	if(pid == 0) /* this is child */
		printf("\n Hello, I am child!\n");
	else if(pid>0) /* this is parent */
		printf("\n Hello, I am parent!\n");
}
```

- pid = fork();
  - 운영체제에서 fork를 실행해 달라고 호출
  - 이 때 복제 생성
  - 복제 된 자식은 main함수 위부터 실행되는게 아니라 fork() 이후부터 실행됨
    - 프로그램카운터가 if문을 가리키기 때문에 if문부터 실행됨
  - 복제를 해놓으니 자기가 원본이라고 하고 부모를 복제본 취급을 해버리는 상황발생
  - 모두 똑같은 프로세스를 따라야 하는 상황 발생
- Parent Process
  - pid > 0
- Child process
  - pid = 0

- 이렇게 나누어야 다른 일을 할 수 있음
  - fork() 결과값으로 구분 가능

### exec() 시스템 콜

- 각기 다른 프로그램들을 실행시켜야 함
- 어떤 프로그램을 완전히 새로운 프로세스로 태어나게 함
- A porcess can excute a different progeam by the exec() system call.
  - replaces the memory image of the caller with a new program.

```c++
int main()
{
	int pid;
	pid = fork()
	if(pid == 0) /* this is child */
	{
		printf("\n Hello, I am child! New I'll run date\n");
		execlp("/bin/date", "/bin/date", (char*)0)
	}
	else if(pid>0) /* this is parent */
		printf("\n Hello, I am parent!\n");
}
```

- execlp 
  - 이걸 만나면 완전히 새로운 걸로 덮어씌워줌
  - main()부터 실행 됨

- 꼭 자식이 할 필요는 없음
- fork를 빼고 해도 됨
- 25:00