# [KOCW] [운영체제] 4. System Structure & Program Execution 2

### System Structure & Program Execution

- 컴퓨터 == 호스트라고도 부름
  - cpu와 메모리로 구성
- cpu는 매 순간 메모리에 올라와있는 기계어를 처리함
  - 프로그램 카운터가 가리키고 있는 것을 실행
  - cpu에서 인스트럭션을 실행하면 다음 것을 다시 할당
  - 프로그램이 항상 순차적으로 실행되는 게 아님
    - 그럼 다른 주소로 점프해서 실행해야 함
  - cpu는 아주 빠른 일꾼
    - cpu 안에 있는 레지스터로 실행됨(프로그램 카운터가 가리키는 주소)
  - 다음 인스트럭션을 실행하기 전에 인터럽트를 확인하고 들어왔다면 인스트럭션을 실행하는게 아니라 cpu 제어권이 운영체제에 넘겨짐
  - 모드 빗이 0이냐 1이냐
    - 0이면 모든 기계어 집합 실행 가능
    - 1이면 한정된 기계어 집합 실행 가능
      - 사용자 프로그램을 전부 믿을 수 없기에 이런 것을 막기위해
  - 사용자 프로그램이 운영체제에게 요청할 때 시스템 콜을 사용
    - 사용자 프로그램이 운영체제 함수를 로출할 때 의도적으로 cpu에 인터럽트를 걸어서 i/o를 수행하도록 함
  - 타이머가 인터럽트를 걸 수도 있음
    - 사용자 프로그램이 계속 cpu를 사용하지 못하도록

### 동기식 입출력과 비동기식 입출력

#### 동기식 입출력 (synchronous I/O)

- I/O 요청 후에 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
  - I/O까지 가서 작업을 모두 보고 오는 것
  - I/O가 끝나야지 사용자 프로그램 가능
  - 보통 디스크에서 뭘 읽어온 다음에 다음 작업을 할 수 있는게 보통
- 구현 방법 1
  - I/O가 끝날 때까지 cpu를 낭비 시킴
  - 매시점 하나의 I/O만 일어날 수 있음
- 구현 방법 2
  - I/O가 완료될 때까지 해당 프로그램에게서 cpu를 빼앗음
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄세움
  - 다른 프로그램에게 cpu를 줌

#### 비동기식 입출력 (aynchronous I/O)

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
  - 지금 I/O 결과를 안 보고도 할 수 있는 작업들이 있으니 그 작업을 하도록 작성
  - 읽어와서 할 수 있는 작업은 읽어 온 후에 진행
  - 스토리지에 데이터를 쓰는 것은 동기적으로 보다 비동기적으로 사용, write

I/O가 끝났다는 것은 인터럽트로 알려줌

22:57