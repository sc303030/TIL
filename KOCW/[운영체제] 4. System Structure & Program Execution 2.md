# [KOCW] [운영체제] 4. System Structure & Program Execution 2
출처 : http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e
### System Structure & Program Execution

- 컴퓨터 == 호스트라고도 부름
  - cpu와 메모리로 구성
- cpu는 매 순간 메모리에 올라와있는 기계어를 처리함
  - 프로그램 카운터가 가리키고 있는 것을 실행
  - cpu에서 인스트럭션을 실행하면 다음 것을 다시 할당
  - 프로그램이 항상 순차적으로 실행되는 게 아님
    - 그럼 다른 주소로 점프해서 실행해야 함
  - cpu는 아주 빠른 일꾼
    - cpu 안에 있는 레지스터로 실행됨(프로그램 카운터가 가리키는 주소)
  - 다음 인스트럭션을 실행하기 전에 인터럽트를 확인하고 들어왔다면 인스트럭션을 실행하는게 아니라 cpu 제어권이 운영체제에 넘겨짐
  - 모드 빗이 0이냐 1이냐
    - 0이면 모든 기계어 집합 실행 가능
    - 1이면 한정된 기계어 집합 실행 가능
      - 사용자 프로그램을 전부 믿을 수 없기에 이런 것을 막기위해
  - 사용자 프로그램이 운영체제에게 요청할 때 시스템 콜을 사용
    - 사용자 프로그램이 운영체제 함수를 로출할 때 의도적으로 cpu에 인터럽트를 걸어서 i/o를 수행하도록 함
  - 타이머가 인터럽트를 걸 수도 있음
    - 사용자 프로그램이 계속 cpu를 사용하지 못하도록

### 동기식 입출력과 비동기식 입출력

#### 동기식 입출력 (synchronous I/O)

- I/O 요청 후에 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
  - I/O까지 가서 작업을 모두 보고 오는 것
  - I/O가 끝나야지 사용자 프로그램 가능
  - 보통 디스크에서 뭘 읽어온 다음에 다음 작업을 할 수 있는게 보통
- 구현 방법 1
  - I/O가 끝날 때까지 cpu를 낭비 시킴
  - 매시점 하나의 I/O만 일어날 수 있음
    - cpu도 낭비고 i/o도 낭비
- 구현 방법 2
  - I/O가 완료될 때까지 해당 프로그램에게서 cpu를 빼앗음
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄세움
  - 다른 프로그램에게 cpu를 줌
    - 다른 i/o가 또 요청을 보내고 또 다른 i/o요청이 오면 던져주고..

#### 비동기식 입출력 (aynchronous I/O)

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
  - 지금 I/O 결과를 안 보고도 할 수 있는 작업들이 있으니 그 작업을 하도록 작성
  - 읽어와서 할 수 있는 작업은 읽어 온 후에 진행
  - 스토리지에 데이터를 쓰는 것은 동기적으로 보다 비동기적으로 사용, write

I/O가 끝났다는 것은 인터럽트로 알려줌

### 인터럽트(Interrupt)

- 키보드 두드리면 인터럽트를 걸어서 하는데 인터럽트를 많이 당하면 오버헤드가 뒤따름
- 그래서 DMA 장치를 달아서 메모리에 직접 접근
  - 작은 요청은 모아서 한 번에 cpu에 인터럽트를 걸어버림

### DMA(Direct Memory Access)

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용함
  - 빠른 입출력 장치는 cpu에 인터럽트를 많이 걸기 때문에 dma를 사용
- cpu의 중재 없이 device controller가 device의 버퍼 스토리지의 내용을 메모리에 block단위로 직접 전송함
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

### 서로 다른 입출력 명령어

- 일반적인 i/o 방식
  - 메모리만 접근하는 인스트럭션
  - 디바이스 인스트럭션
    - 각 디바이스마다 i/o접근
- i/o에 연장 주소를 붙여서 접근

### 저장장치 계층 구조

|  Primary  |               |
| :-------: | :-----------: |
|           |   Registers   |
|           | Cache Memory  |
|           |  Main Memory  |
| Secondary |               |
|           | Magnetic Disk |
|           | Optical Disk  |
|           | Magentic Tape |

- 위로 갈수록 속도가 빠른 매체
- 단위 공간당 단위 가격이 비싸서 용량이 적음
- 휘발성이냐 
  - 세컨더리는 비휘발성
  - 프라이머리는 휘발성 매체
    - 메인 메모리 윗단은 휘발성
    - 아랫단은 비휘발성
- cpu가 접근 가능하면 프라이머리
  - 아니면 세컨더리
  - 바이트 단위로 접근이 가능하냐 아니냐

- cpu가 인스트럭션을 처리하는데 그래서 빠름
- 캐시 메모리는 메인 메모리와 cpu에서 속도 차이를 조절하기 위한 중간 단계
- 그래서 캐쉬 메모리에 올려놓는걸 캐싱이라고 함
  - 용량이 크지 않아서 많이는 못함
  - 그래서 어떤 걸 올려놓는가> 그게 캐싱 관리

### 프로그램의 실행(메모리 load)

- 파일시스템의 파일을 실행하면 메모리에 올라가서 그게 프로세스가 되어서 실행이 됨
- 물리적으로 바로 올라가는게 아니라 중간에 가상 메모리에 올라감
  - 그 프로그램만의 독자적인 주소 공간이 생성됨
  - 코드, 데이터, 스택으로 구성됨
  - 코드는 cpu에서 실행할 기계어 코드
  - 데이터는 변수 즉, 프로그램이 실해하는 자료구조
  - 스택은 함수로 되어있어서 함수를 호출하거나 리턴할때 
- 이걸 물리적인 메모리에 올려서 실행
- 커널은 부팅 후 항상 메모리에 상주하지만 프로그램은 아님
  - 그래서 필요한 부분만 메모리에 올림
  - 주소공간중에서 필요한 부분은 메모리에 올리고 나머지는 디스크의 스왑 공간에 내려와있음
  - 그래서 가상 메모리라고 부름
  - 스왑 공간은 전원이 나가면 의미없음
    - 프로그램이 종료되니
    - 메모리 공간의 연장용도

44:55