# [백기선] 6주차 과제 : 상속

## 1. 자바 상속의 특징

### 상속의 개념

- 부모가 자식에게 물려주는 행위
- 상위(부모)클래스의 멤버를 하위(자식)클래스에 물려주는 것
- 클래스의 변수와 메소드를 사용하는 것

### 장점

- 코드의 중복 감소
- 유지 보수 시간도 감소

### 특징

- 선택적 상속이 불가능
  - 상속되는 클래스의 속성 혹은 기능을 선택적으로 상속받을 수 없음
  - 전부 상속받거나 혹은 아예 상속받지 않거나 해야함
- 단일 상속만 가능
  - 다중 상속의 경우 문제가 생길 수 있어서 자바 시스템에서 지원하지 않음
  - 필요없는 부분까지 받기 때문에 무거워져서 자바는 인터페이스 다중 구현을 제공함
- 생성자는 상속되지 않음
  - 생성자는 클래스 이름과 동일하게 써야 하는데 상속을 하게 되면 클래스 이름이 달라지기 때문에 클래스 이름과 동일하게 사용할 수 없음
  - 대신 super(a,b)처럼 호출은 가능하다.
    - 이것은 첫번 째 줄에서만 가능

## 2. spuer 키워드

- 부모를 찾는 키워드
- 자식 클래스가 부모 클래스의 메소드를 override하면 부모클래스의 메소드 사용 불가
  - 사용하기 위해서 super키워드를 사용하게 됨

[부모 클래스]

```java
public class ParentClass {
    public first(){
        
    }
    
    public void method(){
        System.out.println("부모 클래스 입니다.");
    }
}
```

[자식 클래스]

````java
public class ChildClass extends ParentClass{
    @Override
    public void method(){
        super.method();
        System.out.println("자식 클래스 입니다.");
    }
}
````

- 여기서 super를 통해 부모의 mehtod를 호출하고
- 다시 자식 클래스에서 정의한 내용을 출력한다.

```java
public class Test {
    public static void main(String[] args){
        ChildClass child = new ChildClass();
        child.method();
    }
}
>
부모 클래스 입니다.
자식 클래스 입니다.
```

- super키워드 때문에 부모 클래스의 mathod를 찾아 먼저 그 메소드를 실행시킨다.
- 그 다음의 자식의 method를 실행

## 3. 메소드 오버라이딩

- 상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에 사용할 수 있음
- 하위 클래스에서 메서드를 재정의하여 사용 가능
- 2번 예시 처럼 사용

## 4. 다이나믹 메소드 디스패치

- 다이나믹과 런타임은 동의어로 사용
- 디스패치는 어떤 메소드를 호출할 지 결정하는 것

```java
static class SuperC{
    void print(){
        System.out.println("슈퍼 클래스 입니다.")
    }
}

static class First extends SuperC {
    @Override
    void print(){
        System.out.println("첫번 째 클래스 입니다.")
    } 
}

static class Second extends SuperC {
    @Override
    void print(){
        System.out.println("두번 째 클래스 입니다.")
    } 
}

public static void main(String[] args) {
        Super su = new SuperC(); // 1)
        su.print();
        su = new First(); // 2)
        su.print();
        su = new Second(); // 3)
        su.print();
}
>
슈퍼 클래스 입니다.
첫번 째 클래스 입니다.
두번 째 클래스 입니다.
```

- Super 타입이 객체 su에 자식 객체 First, Second를 대입하면 upcasting가 발생
- su는 대입 될때마다 자식 객체의 주소를 가리킴
- su가 3개의 객체를 모두 가리키는게 아니라 대입될 때마다 순서대로 가리킴

## 5. 추상 클래스

- 자식 클래스에서 반드시 오버라이딩 해야지만 사용할 수 있는 메소드
- 목적은 추상 메소드를 선언하여 추상메소드를 상속받는 자식 클래스가 반드시 구현하도록 하기 위함

```java
abstract class 클래스이름 {
    abstract 반환타입 메소드이름();
}
```

- 중복되는 부분이나 공통적인 부분을 만들어서 자식 클래스는 필요한 부분만 사용

```java
abstract class Animal {
    abstract void cry();
}

class Dog extends Animal {
    void cry() {
        System.out.println("월월");
    }
}

public class Test {
    public static void main(String[] args){
        Dog g = new Dog();
        g.cry();
    }
}
>
월월
```

- Animal 클래스를 상속받는 자식 클래스 Dog는 cry()메소드를 오버라이딩 해야지만 비로소 인스턴스를 생성할 수 있음
- 추상 메소드를 선언하여 자식클래스가 반드시 추상 클래스의 메소드를 사용하도록 하기 위해서 사용함

## 6. final 키워드

- 변수, 메서드, 클래스에서 사용 가능
- 어떤 곳에서 사용되는지에 따라 다른 의미를 가짐
- final를 붙이면 쿠언가를 제한한다는 의미는 공통적

##### 변수

- 변수에 final을 붙이면 해당 변수는 수정할 수 없다는 의미

##### 메소드

- override를 제한하게 됨

##### 클래스

- 상속 불가능한 클래스가 됨

## 7. Object 클래스

- 최상위 class로 모든 class는 Obejct class에서 상속을 받음
- 모든 클래스는 Object클래스의 메서드를 사용할 수 있고, 일부는 재정의 하여 사용할 수 있음

#### 메소드들

1. 객체 비교 equals();
   1.  두 객체가 동일하면 true, 아니면 false를 리턴
2. 객체 해시 코드 hashCode();
   1. 객체의 메모리 번지를 이요해서 해시코드를 만들어서 리턴함, 그래서 객체마다 다른 값을 가짐
3. 객체의 문자 정보 toString()
   1. 객체를 문자열로 표현한 값