# [백준] 14502번 연구소

## 문제

인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.

연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 

일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.

```
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
```

이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.

2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.

```
2 1 0 0 1 1 0
1 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
```

바이러스가 퍼진 뒤의 모습은 아래와 같아진다.

```
2 1 0 0 1 1 2
1 0 1 0 1 2 2
0 1 1 0 1 2 2
0 1 0 0 0 1 2
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
```

벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.

연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.

빈 칸의 개수는 3개 이상이다.

## 출력

첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.

## 예제 입력 1

```
7 7
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
```

## 예제 출력 1 

```
27
```

## 예제 입력 2

```
4 6
0 0 0 0 0 0
1 0 0 0 0 2
1 1 1 0 0 2
0 0 0 0 0 2
```

## 예제 출력 2 

```
9
```

## 예제 입력 3

```
8 8
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
2 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```

## 예제 출력 3 

```
3
```

## 참고답안

```python
import sys
import copy

# sys.setrecursionlimit(10000)
# sys.stdin = open('./test.txt', 'r')
input = sys.stdin.readline

n, m = 0, 0
data = []
result = 0
virusList = []
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


# 모든 방향으로 바이러스 전파
def virus(x, y, copyed):
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx and nx < n and 0 <= ny and ny < m:
            if copyed[nx][ny] == 0:
                copyed[nx][ny] = 2
                virus(nx, ny, copyed)


# 안전 영역 크기 계산
def safe(temp):
    cnt = 0
    for i in range(n):
        for j in range(m):
            if temp[i][j] == 0:
                cnt += 1
    return cnt


def dfs(start, depth):
    global result
    # 울타리가 3개 설치된 경우
    if depth == 3:
        # data를 temp에 넣어주고
        temp = copy.deepcopy(data)

        # 바이러스를 퍼트린 다음
        for i in range(len(virusList)):
            [virusX, virusY] = virusList[i]
            virus(virusX, virusY, temp)

        # 안전한 영역을 계산
        result = max(result, safe(temp))
        return

    for i in range(start, n * m):
        x = (int)(i / m)
        y = (int)(i % m)

        if data[x][y] == 0:
            data[x][y] = 1
            dfs(i + 1, depth + 1)
            data[x][y] = 0



if __name__ == '__main__':
    n, m = map(int, input().split())
    for i in range(n):
        data.append(list(map(int, input().split())))

    for i in range(n):
        for j in range(m):
            if data[i][j] == 2:
                virusList.append([i, j])

dfs(0, 0)
print(result)
```

https://fantastichu.tistory.com/27

https://bcp0109.tistory.com/25

위 2개의 블로그에서 답을 찾았다.

### 조합구하기

- 이 부분은 매우 생소하였다. 매번 어떻게 좌표를 돌려야 하는지, 그냥 for문 2번 돌리면 되는것인지 생각했었는데 좋은 방법을 알아간다. 
- 시간은 완전 단축시킬 수 있다.

`n*m` 개 중에서 3 개를 뽑는 *Combination (조합)* 을 구한다고 생각하면 됩니다.

기존에는 1차원 배열에서 구했던 조합을 2차원에서 구하는 것이 조금 어색할 수 있습니다.

숫자를 `0 ~ n*m` 까지 증가시킬때 `(i/m, i%m)` 을 좌표로 하면 2차원 배열의 모든 인덱스를 탐색할 수 있습니다.

예를 들어 `n = 3, m = 2 인 3*2 배열`을 탐색한다고 할 때

| i    | (i/m, i%m) | 좌표   |
| ---- | ---------- | ------ |
| 0    | (0/2, 0%2) | (0, 0) |
| 1    | (1/2, 1%2) | (0, 1) |
| 2    | (2/2, 2%2) | (1, 0) |
| 3    | (3/2, 3%2) | (1, 1) |
| 4    | (4/2, 4%2) | (2, 0) |
| 5    | (5/2, 5%2) | (2, 1) |

### copy 함수

> 예전에 코딩테스트에서 리스트를 복사하여 푸는 문제가 있었는데 그때는 얕은 복사, 깊은 복사에 대한 개념이 없었다. 복사한 리스트를 변경해도 원본 리스트가 변경되니 그 문제로만 1시간을 잡아먹었고 거의 풀지 못한 채 시험을 마무리 했던 기억이 있어서 copy 함수 만큼은 잊지 못한다.

##### 얕은 복사

- 아래와 같이 그냥 대입연산자 `=`를 사용하여 복사를 하면 같은 메모리 주소를 공유하게 된다. 
- 그래서 listTemp2를 수정하면 listTemp도 같이 수정되는 일이 발생한다.

```python
listTemp = [1,2,3]
print(id(listTemp))
listTemp2 = listTemp
print(id(listTemp2))
>
2788939114056
2788939114056

-----------------------------
listTemp2[2] = 5
print(listTemp)
print(listTemp2)
>
[1, 2, 5]
[1, 2, 5]
```

##### 깊은 복사

- 그래서 필요한게 깊은 복사 `copy.deepcopy`

```
import copy
listTemp = [1,2,3]
print(id(listTemp))
listTemp2 = copy.deepcopy(listTemp)
print(id(listTemp2))
>
2544151078472
2544151080584

---------------------------------------

listTemp2[2] = 5
print(listTemp)
print(listTemp2)
>
[1, 2, 3]
[1, 2, 5]
```

- 깊은 복사를 하면 모두 새롭게 만들어 주기 때문에 메모리 주소가 다르다.
- 그래서 listTemp2를 수정해도 listTemp에 전혀 영향을 주지 않는다.