# R_04

### 파생변수 : 기본변수를 이용하여 새로운 변수를 추가하는 것

#### service_data_stock.csv

```R
stock <- read.csv(file.choose())
str(stock)
> 'data.frame':	247 obs. of  6 variables:
head(stock)
> 
  Date    Open    High     Low   Close Volume
1 30-Oct-15 1345000 1390000 1341000 1372000 498776
2 29-Oct-15 1330000 1392000 1324000 1325000 622336
3 28-Oct-15 1294000 1308000 1291000 1308000 257374
4 27-Oct-15 1282000 1299000 1281000 1298000 131144
5 26-Oct-15 1298000 1298000 1272000 1292000 151996
6 23-Oct-15 1300000 1300000 1278000 1289000 252105
```

```R
stock$diff <- stock$High - stock$Low
>
[1] 49000 68000 17000 18000 26000 22000 26000 23000 17000 16000 10000 39000
mean(stock$diff)
> [1] 27028.34
```

### diff 변수를 이용해서 diff_result 파생변수 생성

#### for ~ 

#### diff_result에 stock$diff이 stock$diff의 평균보다 크면 'mean over' 작으면 'mean under'

```R
stock$diff_result <- ''
size <- nrow(stock)
for (idx in 1:size){
  if(stock$diff[idx] > mean(stock$diff)){
    stock$diff_result[idx] <- 'mean over'
  }else {
    stock$diff_result[idx] <- 'mean under'
  }
}
head(stock)
>
	 Date    Open    High     Low   Close Volume  diff 	diff_result
1 30-Oct-15 1345000 1390000 1341000 1372000 498776 49000   mean over
3 28-Oct-15 1294000 1308000 1291000 1308000 257374 17000  mean under
table(stock$diff_result)
> 
mean over 	mean under 
       104        143 
str(stock)
> 
'data.frame':	247 obs. of  8 variables:
```

- for구문으로 반복하고 if절로 조건을 준다.

- `diff_result` 가 추가되었다.

- `table` 로 범주 요약 정보를 확인 할 수 있다.

###  while(논리값) {

### 조건을 이용해서 탈출

### }

```R
while(idx <= 10){
  print(idx)
  idx <- idx + 1
}
>
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

- 10이하일때만 출력한다.

### 1~100 사이의 5의 배수만 출력하고 싶다면? 

#### if에서 else는 없어도 된다.

```R
while(five <= 100){
  if(five %% 5 ==0){
    cat(five,',')
  }
  five <- five + 1
}
>
5 ,10 ,15 ,20 ,25 ,30 ,35 ,40 ,45 ,50 ,55 ,60 ,65 ,70 ,75 ,80 ,85 ,90 ,95 ,100 ,
```

- if 조건에 맞는 것만 출력한다.

### next(continus), break()

```R
idx <- 0
while(idx <= 10){
  idx <- idx + 1
  if(idx %% 2 != 0){
    next
  }
  print(idx)
}
>
[1] 2
[1] 4
[1] 6
[1] 8
[1] 10
```

- 홀수면 출력하지 않고 다음단계로 지나간다.

- 조건에 만족했을 때 그 이후의 행을 실행하지 않고 바로 올라가버린다. 즉 조건에 해당되면 프린트 안 해준다. 

```R
dx <- 0
while(idx <= 10){
  idx <- idx + 1
  if(idx %% 2 != 0){
    break
  }
   print(idx)
}
>
```

- 2로 나눈 값이 0이 아닌 것, 1로 나누면 0이 아니기 때문에 바로 탈출한다.

- 가장 가까운 루핑을 빠져나간다. 

### NA확인 : is.na()

```R
is.na(c(1,2,3,4,NA))
> [1] FALSE FALSE FALSE FALSE  TRUE
```

- na값이면 `TRUE` 를 반환한다.