# R_시작 

#### letters

```R
> print(letters)
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
```

- 알파벳 순서대로 출력할 수 있다.

#### month.abb

```R
> month.abb
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
```

- 영문으로 1월 ~ 12월까지 앞 3자리만 출력해준다.

#### month.name

```R
> month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December"
```

- 영문으로 1월 ~ 12월 문자 전체를 출력해준다. 

### Package란?

- 함수(Function) + 데이터셋(Dataset)

#### install.packages()

```R
> install.packages("stringr")
Installing package into ‘C:/Users/gh/Documents/R/win-library/4.0’
(as ‘lib’ is unspecified)
URL 'https://cran.rstudio.com/bin/windows/contrib/4.0/stringr_1.4.0.zip'을 시도합니다
Content type 'application/zip' length 216879 bytes (211 KB)
downloaded 211 KB

package ‘stringr’ successfully unpacked and MD5 sums checked

The downloaded binary packages are in
	C:\Users\Public\Documents\ESTsoft\CreatorTemp\Rtmp0OL8Ri\downloaded_packages
```

- 설치할 패키지를 먼저 인스톨한다

#### library()

```R
> library(stringr)
경고메시지(들): 
패키지 ‘stringr’는 R 버전 4.0.2에서 작성되었습니다
```

- 그 다음에 `library` 로 설치한 패키지를 올린다.

#### .libPaths()

```R
> .libPaths()
[1] "C:/Users/gh/Documents/R/win-library/4.0"
[2] "C:/Program Files/R/R-4.0.1/library"   
```

- 현재 사용하고 있는 라이브러리 경로들이 나온다.

#### library()

- 현재 사용하고 있는 라이브러리가 나온다.

### 디버깅(debugging)

> **디버깅**(영어: debugging) 또는 디버그(영어: debug)는 컴퓨터 프로그램 개발 단계 중에 발생하는 시스템의 논리적인 오류나 비정상적 연산(버그)을 찾아내고 그 원인을 밝히고 수정하는 작업 과정을 뜻한다.

- `print()` , `paste()`, `sprintf()`, `cat()`

#### print()

```R
> print('실버를 넘어 골드를 지나 펭티비로 다이아 갈꺼야')
[1] "실버를 넘어 골드를 지나 펭티비로 다이아 갈꺼야"
```

#### sprintf(문자열, 값)

- `%d : 정수` , `%f : 실수`, `%s : 문자` 

```R
> sprintf("%d",123)
[1] "123"
```

```R
> sprintf("Number : %d", 100)
[1] "Number : 100"
```

```R
> sprintf("Number : %d, string : %s", 0808,'pengso')
[1] "Number : 808, string : pengso"
```

-  `"" or ''`  안에 위에 나와있는 정수, 실수, 문자에 따라 형식을 지정한다. `콤마(,)` 뒤에 출력할 값을 적어준다. 

```R
> sprintf("%.2f",123.456)
[1] "123.46"
```

- 2자리에서 반올림한다.

```R
> sprintf("%5d",123)
[1] "  123"
```

- 5자리라고 지정해 주었기 때문에 `123` 앞에 공백 2개가 있다.

```R
> sprintf("%5d",12345)
[1] "12345"
```

- 5자리에 숫자가 5개 있으니 공백이 없다.

```R
> sprintf("%5d",123456) 
[1] "123456"
```

- 자리수를 지정해줘도 자리수가 부족이라도 그냥 출력한다. 

#### cat()

- `print()` 는 기본적으로 행이 바뀐다.

- `cat()` 은 행이 바뀌지 않고, 옆으로 값이 출력된다. 

```R
> myfunc <- function() {
+             total <- 0
+             print('append ...')
+             for(i in 1:10){
+                     total <- total + i
+                     print(i)}
+             print('end')
+           return(total)
+ }
```

- `print()` 로 먼저 출력해본다. 

```R
> myfunc()
[1] "append ..."
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
[1] "end"
[1] 55
```

- 행이 바뀌어서 출력된다.

```R
> myfunc2 <- function() {
+             total <- 0
+             cat('append ...')
+             for(i in 1:10){
+                     total <- total + i
+                     cat(i,"...")}
+             cat('end','\n')
+           return(total)
+ }
```

- `cat() ` 으로 출력해본다.

```R
> myfunc2()
append ...1 ...2 ...3 ...4 ...5 ...6 ...7 ...8 ...9 ...10 ...end 
[1] 55
```

- 행이 바뀌지 않고 옆으로 출력된다. 

### 변수

- `알파벳`, `숫자`, `_`, `.(도트)`로  구성된다(단, 첫글자는 반드시 문자 또는 .)

- **단일형** (단일값들을 담는 타입, 섞이지 않은 값) : vector, matrix, array

- **복수형** (섞여있는 값들(문자+논리+수치등)) : list, data.frame

#### vector

> python에서는 vector 를 list 타입으로 취급한다.

- `c()` , `1:10`

```R
> sample_vec <- c(1,2,3,4,5)
```

```R
> sample_vec
[1] 1 2 3 4 5
```

- `vector` 형식으로 값이 저장되었다.

```R
> sum(sample_vec)
[1] 15
```

- 내가 저장한 `vector` 값들의 합계

```R
> length(sample_vec)
[1] 5
```

- 저장한 `vector` 의 길이
  - 1,2,3,4,5 : 5개여서 5를 반환

```R
> sum(sample_vec) / length(sample_vec)
[1] 3
```

- 15 / 5 = 3 이다.

```R
> mean(sample_vec)
[1] 3
```

- `vector` 의 값 평균이다.

```R
> class(sample_vec)
[1] "numeric"
```

- 숫자형인지 논리형인지 문자형인지 등을 알려주는 함수이다.

```R
> typeof(sample_vec) 
[1] "double"
```

- `double` 은 배정밀도(double precision)수이다. 컴퓨터는 1.000000 정도로 인식하고 있다.
  - 정수인지 실수인지 자세하게 알려준다.
  - 문자형인지 논리형인지도 알려준다.

```R
> mode(sample_vec)
[1] "numeric"
```

- 메모리에 어떻게 저장되는지 알려주는 함수이다. 숫자형(numeric), 문자형(character), 리스트(list), 함수(function) 등이 있다.

#### start : end

```R
sample_vec02 <- 1:10
```

```R
> sample_vec02
 [1]  1  2  3  4  5  6  7  8  9 10
```

- `c()` 형식 이외에도 다음과 같이 `start:end`  형식으로 지정할 수 있다. 

```R
x <- 1:10
y <- x^2
```

#### 산점도

```
plot(x,y)
```

![plot01](./img/Rplot01.png)

### 논리형( Ture, False)

- R에서는 TRUE를 T로 FALSE를 F로 표현할 수 있다. 또한  True는 1, False는 0으로 텀퓨터는 인지한다.

```R
boolean_vec02 <- c(T, F, T, F)
```

```R
> str(boolean_vec02) 
 logi [1:4] TRUE FALSE TRUE FALSE
```

-  R은 인덱스가 1부터 시작한다.

```R
> class(boolean_vec02)
[1] "logical"
```

```R
> typeof(boolean_vec02)
[1] "logical"
```

```R
> mode(boolean_vec02)
[1] "logical"
```

- 타입을 확인하면 모두 논리형이다.

### NA와 NULL

#### is.na()

- 결측치를 확인하는 함수이다.

- **NA** 는 결측치, 즉 값이 빠져있는 경우를 뜻한다.

```R
string_vec <- c('펭하','펭수',NA,'펭빠')
```

```R
> is.na(string_vec)
[1] FALSE FALSE  TRUE FALSE
```

- 결측치가 있는 인덱스에 TRUE를 반환한다.

#### is.null()

- `null` 값을 확인하는 함수이다.

- **NULL** 은 값이 없다는 뜻이다. 

```R
string_vec <- c('펭하','펭수',NULL,'펭빠')
```

```R
> string_vec
[1] "펭하" "펭수" "펭빠"
```

- `null` 값을 넣으면 공백도 아니고 아예 데이터에 없는 존재가 된다.

```R
string_vec <- c('펭하','펭수','','펭빠')
```

```R
> string_vec
[1] "펭하" "펭수" ""     "펭빠"
```

- 공백을 넣으면 공백이 저장되는데 `null` 은 없는 값이된다. 

```R
sample_null <- c(1,2,3,4)
```

```R
> sample_null
[1] 1 2 3 4
```

```R
sample_null <- NULL
```

```R
> sample_null
NULL
```

```R
> is.null(sample_null)
[1] TRUE
```

- `null` 을 지정해주고 값을 초기화 할 수 있다.

### 반복

#### rep(값, 횟수)

- 값을 지정한 횟수만큼 반복한다.

```R
> rep(1:10, 5)
 [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6
[27]  7  8  9 10  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6  7  8  9 10
```

- 1부터 10까지 나열하고 그것을 5번 반복한다.

```R
> rep(1:10, each=5)
 [1]  1  1  1  1  1  2  2  2  2  2  3  3  3  3  3  4  4  4  4  4  5  5  5  5  5  6
[27]  6  6  6  6  7  7  7  7  7  8  8  8  8  8  9  9  9  9  9 10 10 10 10 10
```

- 이번에는 순서대로가 아니라 1부터 5개씩 반복하고 다음 숫자로 넘어간다.

#### seq(from, to, by)

```
> seq(2,10,2)
[1]  2  4  6  8 10
```

